import numpy as np

import mujoco
from gymnasium.envs.mujoco import MujocoEnv

from lucignolo.core.eef_point import EEFPoint
from lucignolo.core.utils import IndexGetter
from lucignolo.controllers.jnt_ctrl import ConstraintJointController
from lucignolo.core.utils import JointGroup

from typing import Dict, List, Optional
from numpy.typing import NDArray
from functools import cached_property
from .base import Controller, NoiseController, get_actuators
from .invdyn_ctrl import IDController, NoisyIDController

class MultiController:
	
	def __init__(self, env: MujocoEnv, actuators_prefix: Optional[str] = None):
		self.controllers: List[Controller] = []
		self.env = env
		self._indexes = IndexGetter(self.env)(subtree_type='anything', check_constraints=False) # get all the actuable dofs, even if constrained

		self.gears = np.ones(self.env.model.nv) # NOTE: consider the gear of unactuated joints as 1

		self.actuators = get_actuators(env, actuators_prefix)
		self.gears[self._indexes['dof_ids']] = self.env.model.actuator_gear[self.actuators, 0]

		self.ranges = self.env.model.actuator_ctrlrange[self._indexes['actuator_ids']]

	def add_controller(self, subtree_type, frame=None, fields=None, noise_var:float=0, noise_lambda=1.0, controller_kwargs: Dict = {}):

		assert (frame is not None and fields is not None) or noise_var > 0, "Expected either a frame and fields or a positive noise variance."

		if frame is None or fields is None:
			CType = NoiseController
			eef = None
		else:
			eef = EEFPoint(frame)
			eef.add_fields(fields)
			
			CType = NoisyIDController if noise_var > 0 else IDController

		controller = CType(env=self.env, subtree_type=subtree_type, eef=eef, noise_var=noise_var, noise_lambda=noise_lambda)
		self.controllers.append(controller)

	def add_joint_controller(self, target_posture: Dict[str, float], control_params: Dict = {}):
		controller = ConstraintJointController(self.env, target_posture=target_posture, control_params=control_params)
		self.controllers.append(controller)

	def step(self):
		"""
		Step all the controllers and sum their outputs.

		NOTE: by passing the desired qvel generated by the previous controller to the next one, 
		we take into consideration the previous contributions for the generation of the current one,
		resulting in better coordination (otherwise each controller would be blind to what the others
		did in the meantime, effectively lagging behind). 
		"""
		
		#qact = self.env.data.qfrc_bias / self.gears
		qact = np.zeros_like(self.env.data.qfrc_bias)

		ctrl = np.zeros((self.env.model.nu), dtype=np.float64)

		for i, cntrlr in enumerate(self.controllers):
			newctrl = cntrlr.step(qact)

			ctrl += newctrl

			qact[self._indexes['dof_ids']] = np.clip(ctrl[self._indexes['actuator_ids']], self.ranges[:,0], self.ranges[:,1])

		return ctrl

	@cached_property
	def active_joints(self):
		"""Return the DoFs controlled by the individual controllers"""

		tot_jgroup: JointGroup = {
			'joint_names': np.array([], dtype=np.int32),
			'joint_ids': np.array([], dtype=np.int32),
			'actuator_names': np.array([], dtype=np.int32),
			'actuator_ids': np.array([], dtype=np.int32),
			'dof_ids': np.array([], dtype=np.int32),
			'q_ids': np.array([], dtype=np.int32),
		}

		for cntrlr in self.controllers:
			jgroup = cntrlr._indexes


			tot_jgroup['joint_names'], idxs = np.unique(np.concatenate((tot_jgroup['joint_names'], jgroup['joint_names'])), return_index=True)

			for key, value in jgroup.items():

				if key == "joint_names": continue
				
				unique_values, indices = np.unique(np.concatenate((tot_jgroup[key], value)), return_index=True)
				tot_jgroup[key] = np.concatenate((tot_jgroup[key], value))[idxs]

		return tot_jgroup
	
class SmoothMultiController(MultiController):
	"""Smooth the control signal with a low-pass filter."""

	def __init__(self, env: MujocoEnv, alpha: float = 0.5):
		super().__init__(env)
		self.alpha = alpha
		self.prev_ctrl = np.zeros((self.env.model.nu), dtype=np.float64)

	def step(self):
		ctrl = super().step()
		ctrl = self.alpha * ctrl + (1 - self.alpha) * self.prev_ctrl
		self.prev_ctrl = ctrl
		return ctrl
import numpy as np

import mujoco
from gymnasium.envs.mujoco import MujocoEnv

from core.eef_point import EEFPoint
from src.core.utils import IndexGetter
from src.controllers.jnt_ctrl import ConstraintJointController
from src.core.utils import JointGroup

from typing import Dict, List
from numpy.typing import NDArray
from functools import cached_property
from src.controllers.invdyn_ctrl import Controller, IDController

class NoiseGenerator:
	def __init__(self, ranges: NDArray,  noise_var: float, noise_lambda: float = 1.0) -> None:
		self.nv = noise_var

		self.stds = (ranges[:,1] - ranges[:,0]) / 6 # assume gaussian with limits = 3*std
		self.mus = (ranges[:,1] + ranges[:,0]) / 2
		self.prev_noise = np.zeros_like(self.mus)
		self._lambda = noise_lambda
	def __call__(self):
		noise = self._lambda * (self.nv * self.stds * np.random.randn(len(self.mus)) + self.mus) + (1-self._lambda)*self.prev_noise
		self.prev_noise = noise
		return noise

class NoisyIDController(IDController):

	def __init__(self, env: MujocoEnv, eef: EEFPoint, subtree_type: str, noise_var: float, noise_lambda: float = 1.0, *args, **kwargs):
		super().__init__(env, eef, subtree_type)
		self.noise_gen = NoiseGenerator(self.model.actuator_ctrlrange[self._indexes['actuator_ids']], noise_var, noise_lambda)

	def step(self, qact = None):
		ctrl = super().step(qact)
		ctrl[self._indexes['actuator_ids']] += self.noise_gen()
		return ctrl

class NoiseController(Controller):

	def __init__(self, env: MujocoEnv, subtree_type: str, noise_var: float, noise_lambda: float = 1.0, *args, **kwargs):

		super().__init__(env, subtree_type)
		self.noise_gen = NoiseGenerator(self.model.actuator_ctrlrange[self._indexes['actuator_ids']], noise_var, noise_lambda)

	def step(self, qact = None):
		ctrl = np.zeros((self.model.nu), dtype=np.float64)
		ctrl[self._indexes['actuator_ids']] += self.noise_gen()
		return ctrl
	
class MultiController:
	
	def __init__(self, env: MujocoEnv):
		self.controllers: List[Controller] = []
		self.env = env
		self._indexes = IndexGetter(self.env.model)(subtree_type='anything', check_constraints=False) # get all the actuable dofs, even if constrained

		self.gears = np.ones(self.env.model.nv) # NOTE: consider the gear of unactuated joints as 1
		self.gears[self._indexes['dof_ids']] = self.env.model.actuator_gear[self.env.mimo_actuators, 0]

		self.ranges = self.env.model.actuator_ctrlrange[self._indexes['actuator_ids']]

	def add_controller(self, subtree_type, frame=None, fields=None, noise_var:float=0, noise_lambda=1.0, controller_kwargs: Dict = {}):

		assert (frame is not None and fields is not None) or noise_var > 0, "Expected either a frame and fields or a positive noise variance."

		if frame is None or fields is None:
			CType = NoiseController
			eef = None
		else:
			eef = EEFPoint(frame)
			eef.add_fields(fields)
			
			CType = NoisyIDController if noise_var > 0 else IDController

		controller = CType(env=self.env, subtree_type=subtree_type, eef=eef, noise_var=noise_var, noise_lambda=noise_lambda)
		self.controllers.append(controller)

	def add_joint_controller(self, target_posture: Dict[str, float], control_params: Dict = {}):
		controller = ConstraintJointController(self.env, target_posture=target_posture, control_params=control_params)
		self.controllers.append(controller)

	def step(self):
		"""
		Step all the controllers and sum their outputs.

		NOTE: by passing the desired qvel generated by the previous controller to the next one, 
		we take into consideration the previous contributions for the generation of the current one,
		resulting in better coordination (otherwise each controller would be blind to what the others
		did in the meantime, effectively lagging behind). 
		"""
		
		#qact = self.env.data.qfrc_bias / self.gears
		qact = np.zeros_like(self.env.data.qfrc_bias)

		ctrl = np.zeros((self.env.model.nu), dtype=np.float64)

		for i, cntrlr in enumerate(self.controllers):
			newctrl = cntrlr.step(qact)

			ctrl += newctrl

			qact[self._indexes['dof_ids']] = np.clip(ctrl[self._indexes['actuator_ids']], self.ranges[:,0], self.ranges[:,1])

		return ctrl

	@cached_property
	def active_joints(self):
		"""Return the DoFs controlled by the individual controllers"""

		tot_jgroup: JointGroup = {
			'joint_names': np.array([], dtype=np.int32),
			'joint_ids': np.array([], dtype=np.int32),
			'actuator_names': np.array([], dtype=np.int32),
			'actuator_ids': np.array([], dtype=np.int32),
			'dof_ids': np.array([], dtype=np.int32),
			'q_ids': np.array([], dtype=np.int32),
		}

		for cntrlr in self.controllers:
			jgroup = cntrlr._indexes


			tot_jgroup['joint_names'], idxs = np.unique(np.concatenate((tot_jgroup['joint_names'], jgroup['joint_names'])), return_index=True)

			for key, value in jgroup.items():

				if key == "joint_names": continue
				
				unique_values, indices = np.unique(np.concatenate((tot_jgroup[key], value)), return_index=True)
				tot_jgroup[key] = np.concatenate((tot_jgroup[key], value))[idxs]

		return tot_jgroup
	
class SmoothMultiController(MultiController):
	"""Smooth the control signal with a low-pass filter."""

	def __init__(self, env: MujocoEnv, alpha: float = 0.5):
		super().__init__(env)
		self.alpha = alpha
		self.prev_ctrl = np.zeros((self.env.model.nu), dtype=np.float64)

	def step(self):
		ctrl = super().step()
		ctrl = self.alpha * ctrl + (1 - self.alpha) * self.prev_ctrl
		self.prev_ctrl = ctrl
		return ctrl